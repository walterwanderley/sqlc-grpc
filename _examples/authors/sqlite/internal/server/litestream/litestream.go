// Code generated by sqlc-grpc (https://github.com/walterwanderley/sqlc-grpc).

package litestream

import (
	"context"
	"errors"
	"os"
	"path/filepath"
	"strings"

	"github.com/benbjohnson/litestream"
	lss3 "github.com/benbjohnson/litestream/s3"
)

func Replicate(ctx context.Context, dsn, replicaURL string) (*litestream.DB, error) {
	if i := strings.Index(dsn, "?"); i > 0 {
		dsn = dsn[0:i]
	}
	dsn = strings.TrimPrefix(dsn, "file:")

	lsdb := litestream.NewDB(dsn)

	path := filepath.Base(replicaURL)
	bucket, region, endpoint, forcePathStyle := lss3.ParseHost(strings.TrimSuffix(replicaURL, path))

	client := lss3.NewReplicaClient()
	client.Bucket = bucket
	client.Path = path
	client.Region = region
	client.Endpoint = endpoint
	client.ForcePathStyle = forcePathStyle

	replica := litestream.NewReplica(lsdb)
	replica.Client = client
	lsdb.Replica = replica

	if err := restore(ctx, replica); err != nil {
		return nil, err
	}

	if err := lsdb.Open(); err != nil {
		return nil, err
	}

	if err := lsdb.Sync(ctx); err != nil {
		return nil, err
	}

	return lsdb, nil
}

func restore(ctx context.Context, replica *litestream.Replica) error {
	if _, err := os.Stat(replica.DB().Path()); err == nil {
		return nil
	} else if !os.IsNotExist(err) {
		return err
	}

	opt := litestream.NewRestoreOptions()
	opt.OutputPath = replica.DB().Path()

	err := replica.Restore(ctx, opt)
	if err != nil && !errors.Is(err, litestream.ErrTxNotAvailable) {
		return err
	}
	return nil
}
